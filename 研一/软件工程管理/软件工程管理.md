### 没有银弹

摩尔定律：硬件每隔18个月翻一倍

但是软件受制于人的智力，软件发展远跟不上硬件的发展

软件开发极端困难，没有接近，新的方法在十年内不能带来进步

软件开发中的根本任务是打造由抽象软件实体构成的复杂概念结构，只能由人的智力完成。

次要任务是使用编程语言表达这些抽象实体，在空间和时间限制内将它们映射成机器语言，只是一些敲代码工作。

除非次要任务占了所有工作的90%，否则减少次要工作的时间不能提升效率的数量级。

将现实世界的问题映射到计算机中的工作，这个过程没有工具能辅助完成。这个过程为什么困难：

```我认为软件开发中困难的部分是规格化、设计和测试这些概念上的结构，而不是对概念进行表达和对实现逼真程度进行验证。```

**规格化**：设计功能难于技术难度 微信朋友圈（创意）

​               银行业务（过多的细节）

**测试**：高可用 汽车刹车

现代软件系统中无法规避的内在特性：复杂度、一致性、可变性和不可见性。

新的思想和技术如何在现在的软件开发中进行组织

银弹：优秀的程序员？人与人的差距









软件工程的特殊性：过程更重要还是人更重要？每个人有不同的价值观

度量

怎么改进软件过程：

1. 理解当前状态
2. 希望达到的进度
3. 根据优先度建立改进过程
4. 产生计划完成
5. 利用资源去完成

这样的结果：[CMM五级模型](https://wiki.mbalib.com/zh-tw/%E8%83%BD%E5%8A%9B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B#)

足够的准备和估算，责任明晰

Management oversight 提前做好开发计划

QA 通过人/工具/过程，来保证、监督 （带来了较高的成本）

变更 限制变更 变更控制委员会

在五级模型中 实现从一级到二级是最大的一步  repeatable process 上一次成功下一次也能成功

如果有变化：技术变化、人员变化... 那需要第三级 defined 写下来形成规范 有process group负责规范、培训、维护工具、devops

第四级 定量 编码、开发...时间的比例，质量和效率的差异 这就需要测试 度量有被时是高成本、破坏性的，争议性很大 在第四级的收集数据是手动的，成本高

第五级 全自动收集数据 主动优化 修bug：测试、code review 需要使用技术改进修bug的效率、开销

很少有人能做到cmm五级 投入代价太大、效率低、官僚化



### Scrum

简单 excel一条条写下需求 强制优先级排序

必须先做优先级高的 估算做到多少

pdca plan do check action

每一天迭代产物：潜在可发布的产品增量

每一个迭代要求功能要做完、可交付

迭代评审与演示会议 演示正式运行的软件而非ppt

回顾会议 反思

scrum3355



敏捷软件开发

user story

3c原则 card conversation confirmation定义完成了(**DoD** definition of done)

故事地图从顶向下分拆的过程中会损失细节

sprint计划会议 product owner**必须**参加计划会议 在这个阶段重要 scope esitimate importance 和开发人员交流来优化这三个变量 不能只有一方决定

scrum通常为两个星期

估算非常困难 但是计划需要估算 

估算单位(story point) 相对的单位 选可识别的最小用例作为两个单位 缩小人与人之间的误差（人与人差十倍 估算不准）

估算单位的另一种选择 S M L

估算过程 计划扑克 牌的数字为翻倍的关系更好判断 估算过程中每人一组牌 每个团队成员**同时**翻牌 讨论估算结果差异（为什么估2/4/8...） product owner解释明确需求的细节之后再投票一次 没有达成一致再讨论

估算有差异的原因 需求理解不同 技术不熟悉（谁都不懂的技术需要启动**风险**控制，评估商业价值，如果是商业价值核心需要所有人解决掉再做后面的）

“金发女孩”估算技术 尽可能将每个工作项拆到差不多大 分割或组合 适合看板方法

根据团队习惯/喜欢来选择

故事和任务(task) 故事不改任务随时改 故事给product owner看任务给程序员看

先估算再拆分 或 先拆分再估算 没有谁对谁错 拆分可能已经包含了估算的过程

计划会议产物 sprint信息页 团队能做多少工作量 总共多少工作量

sprint管理 每一天的管理使用白板 放上故事、任务 移动到正在做、已完成 更新燃尽图

进度跟踪工具 燃尽图 横坐标时间 纵坐标剩下的故事点数

每日站会 不超过15分钟 同步信息、发现问题 昨天干了什么、今天打算做什么、有没有遇到困难 

每个周期结束 演示会议 演示可运行的软件 不要ppt 适度的压力

回顾会议 哪些做的好 哪些不够 怎样在下个周期做得更好 使用白板

局限性 只有管理实践 没有技术实践





### 极限编程  XP(Extreme Programming)

联想

短发布周期

Tesing测试 TDD测试驱动设计

Refacoring 系统需要你重构时再重构 bad smell  很多工作在于Rename，为了代码的可读性 敏捷软件开发反对写注释，因为写注释代表代码可读性不好

Pair Programming 结对编程 一个人写代码一个人想问题（test case、简化...） driver&navigator partner可以更换

Collective Owership （相对的Individual Ownership，每个人负责自己的代码，每个人不去改别人的代码） 重构/Rename更改别人的代码的前提条件

Continuous Integration 持续集成  及时解决集成时的冲突

40-Hour Work 反对加班 每个人都在全速工作，没必要加班

On-site Customer 顾客和开发团队坐在一块

Coding Standards 编码规范 命名规范



每一个实践单独来看可能有缺陷，但是缺陷可以被其他的实践弥补，所以将他们合并起来

粗糙的计划可以被短发布弥补，发现了问题也只是两周的问题

Short Release短发布周期需要持续集成减少打包成本，测试继承开发

Simple Design简单设计 需要重构

Testing 程序员不写单元测试 （不过现在大模型的帮助低成本地生成单元测试）

Refactoring 重构做错了也会在持续集成时发现

Pair Programming 不可能真正地实现结对编程，很多人认为可能降低劳动生产率。支持者认为可以提升代码质量，短期内降低劳动生产力但是有利于长期开发的效率。 结对作用也取决于两人的相处（也许现在可以有AI的帮助）

40-Hour Work 很难做到 

On-Site Customer 很难做到

Coding Standards

Simple design - TDD - CICD - Refactoring 这四个实践是紧密相连的



工作空间 

让参与一个项目的人坐到一起 可能有私人空间来不受打扰

让参观者快速了解项目内容 放置故事卡片 

工位没有格挡 pair programming的需要

水和小吃



测试代码自己不存在耦合 所有的测试应该是自动化的

程序员写单元测试 客户写功能测试（可能需要程序员帮客户写）

单元测试必须在任何时间通过 功能测试不用



设计已死

big up front design 冗余的前期设计

evolutionary design 在开发过程中调整设计

设计的目的是维持代码的生存 生存指写新功能时依然使用原来的代码 如果不如抛弃原来的去写新的那么就说这个代码死了

planned design 不能一开始就把所有的问题想清楚

变更需求 有弹性的设计需要先见之明猜测未来的变更

XP的争议 主张evolutionary design 而非 planned design

简单设计 不要一开始就做有弹性的设计 即使增加设计的成本很低也不要做 后面的维护成本、理解难度、测试都有成本

don't repeat yourself 去除重复

不要一开始就关注写的最简单 可以后面重构 在开发过程中不断调整

patterns 重要但是需要时再使用

UML与XP不兼容 画图的目的是为了交流 画出重要的部分，保持简短，修改时不用整个重画

不提倡架构师 提倡教练

refactoring处理所有的设计吗？ 有些设计还是早做好（比如国际化） 考虑成本

设计并非已死 设计的本质已经改变



持续集成

TDD的代价相当大 有争议

CICD没有争议 效果明显 属于可以优先考虑引入的技术

传统瀑布模型属于单次集成 集成时的风险很大

持续集成严重依赖于工具 有一套工具使得CICD的代价不高

过程：拉下代码（上一次迭代完成的没有Bug的代码）；开发编译测试 测试要跑之前的所有测试，如果是特别大的项目（超过百万行）需要一些别的办法，比如分模块；将别人的代码更新到本地，修复冲突，再提交；提交后在集成服务器上进行集成（自动化，使用触发器），需要在集成服务器上成功集成

尽可能快速的提交代码，后提交的人需要解决冲突

跨模块的bug非常麻烦，持续集成是解决跨模块bug的办法

尽可能把所有文件上传，包括库、配置文件...

branch 可用可不用 根据开发习惯决定

构建得是自动化的，编写构建脚本，确保用一个命令完成，不要在ide里构建（考虑在不同设备上都能一键构建）

自动化测试，测试失败让构建失败（对于大项目有时候会在有些测试失败也不让主构建失败）

最好是每天至少提交一次，频繁提交

长时间的构建是很糟糕的，不超过10分钟

必须要有自动化部署脚本、自动化回滚脚本（十分钟之内回滚）

部署时可能会采用的方法  灰度发布（先对一部分用户进行部署） 、AB测试   都需要自动化部署的能力

持续集成的好处在于降低风险，尽早发现bug

持续集成的脚本只需要一个人完成，而TDD需要每个人去做